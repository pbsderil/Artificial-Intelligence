;; The 8-Puzzle Program

(defmacro while (test &body body)
  "Execute body while the test is true."
  `(do () ((not ,test) nil) ,@body))

(defun Find-Blank (puzzle n)
  (if (eq (car puzzle) 0)
      (+ n 0)
    (if (cdr puzzle)
	(Find-Blank (cdr puzzle) (+ n 1))
      -1))
)

(defun Is-Equal (puzzle1 puzzle2)
  (or (and (null puzzle1) (null puzzle2)) 
      (and puzzle1 puzzle2 (eq (car puzzle1) (car puzzle2))
	   (Is-Equal (cdr puzzle1) (cdr puzzle2))))
)

(defun Heuristic1 (puzzle)
  (setq n 0 val 0)
  (while (< n 9)
    (if (not (eq (nth n puzzle) n)) (setq val (+ val 1)))
    (setq n (+ n 1)))
  val
)

(defun Heuristic2 (puzzle) ; Manhattan Distance
  (setq n 0 val 0)
  (while (< n 9)
    (setq val (+ val (abs (- (/ n 3) (/ (nth n puzzle) 3)))
		(abs (- (mod n 3) (mod (nth n puzzle) 3)))))
    (setq n (+ n 1)))
  val
)

(defun Exchange (puzzle n1 n2)
  (if (>= n1 n2) (error "Exchange error"))
  (if (or (< n1 0) (< n2 0) (> n1 8) (> n2 8)) (error "Index error"))
  (if (= n1 0) (setq newpzl (list (nth n2 puzzle)))
    (setq newpzl (list (car puzzle))))
  (setq n 1)
  (while (< n n1)
    (setq newpzl (append newpzl (list (nth n puzzle)))) (setq n (+ n 1)))
  (if (> n1 0)
      (and (setq newpzl (append newpzl (list (nth n2 puzzle))))
	   (setq n (+ n 1))))
  (while (< n n2)
    (setq newpzl (append newpzl (list (nth n puzzle)))) (setq n (+ n 1)))
  (setq newpzl (append newpzl (list (nth n1 puzzle))))
  (setq n (+ n 1))
  (while (< n (length puzzle))
    (setq newpzl (append newpzl (list (nth n puzzle)))) (setq n (+ n 1)))
  newpzl
)

(defun Make-Move (puzzle move)
  (setq z (Find-Blank puzzle 0))
  (cond ((eq move 'left) (setq puzzle (Exchange puzzle (- z 1) z)))
	((eq move 'right) (setq puzzle (Exchange puzzle z (+ z 1))))
	((eq move 'up) (setq puzzle (Exchange puzzle (- z 3) z)))
	((eq move 'down) (setq puzzle (Exchange puzzle z (+ z 3)))))
  (setq *GMoveCount* (+ *GMoveCount* 1))
  puzzle
)

(defun Expand (puzzle move movehistory)
  (if (null move)
      (and (setq z (Find-Blank puzzle 0))
	   (cond ((= z 8) (setq move 'left))
		 ((= z 2) (setq move 'left))
		 ((= z 0) (setq move 'right))
		 ((= z 6) (setq move 'up))
		 ((= z 1) (setq move 'left))
		 ((= z 3) (setq move 'up))
		 ((= z 4) (setq move 'left))
		 ((= z 5) (setq move 'left))
		 ((= z 7) (setq move 'left)))))
  (setq puzzle (Make-Move puzzle move))
  (setq z (Find-Blank puzzle 0))
  (cond ((= z 0) (if (eq move 'left)
		     (setq next '(down)) (setq next '(right))))
	((= z 2) (if (eq move 'right)
		     (setq next '(down)) (setq next '(left))))
	((= z 6) (if (eq move 'left)
		     (setq next '(up)) (setq next '(right))))
	((= z 8) (if (eq move 'right)
		     (setq next '(up)) (setq next '(left))))
	((eq move 'left)
	 (cond ((= z 1) (setq next '(left down)))
	       ((= z 3) (setq next '(up down)))
	       ((= z 4) (setq next '(left up down)))
	       ((= z 7) (setq next '(left up)))))
	((eq move 'up)
	 (cond ((= z 1) (setq next '(left right)))
	       ((= z 3) (setq next '(up right)))
	       ((= z 4) (setq next '(left up right)))
	       ((= z 5) (setq next '(left up)))))
	((eq move 'right)
	 (cond ((= z 1) (setq next '(right down)))
	       ((= z 4) (setq next '(up right down)))
	       ((= z 5) (setq next '(up down)))
	       ((= z 7) (setq next '(up right)))))
	((eq move 'down)
	 (cond ((= z 3) (setq next '(right down)))
	       ((= z 4) (setq next '(left right down)))
	       ((= z 5) (setq next '(left down)))
	       ((= z 7) (setq next '(left right))))))
  (cons puzzle (list (append (list move *GMoveCount*) movehistory) next))
)

